- name: create droplet
  hosts: localhost
  gather_facts: false
  connection: local
  vars:
    digitalocean_token: "{{ lookup('ansible.builtin.env', 'DIGITALOCEAN_TOKEN') }}"
  tasks:
    - name: Create SSH key
      community.digitalocean.digital_ocean_sshkey:
        oauth_token: "{{ digitalocean_token }}"
        name: argocd-poc
        ssh_pub_key: "{{ lookup('file', '~/.ssh/id_rsa.pub') }}"
        state: present
      register: ssh_key

    - name: Create a new Droplet
      register: droplet
      community.digitalocean.digital_ocean_droplet:
        oauth_token: "{{ digitalocean_token }}"
        state: present
        name: argocd-poc
        unique_name: true
        size: s-2vcpu-4gb
        region: nyc3
        image: debian-11-x64
        wait_timeout: 500
        ssh_keys:
          - "{{ ssh_key.data.ssh_key.id }}"

    - name: register IP as fact
      ansible.builtin.set_fact:
        droplet_ip: "{{ (droplet.data.droplet.networks.v4 | selectattr('type', 'equalto', 'public')).0.ip_address | default('<none>', true) }}"
        cacheable: true

    - name: print droplet IP
      ansible.builtin.debug:
        msg: "droplet IP: {{ ansible_facts.droplet_ip }}"

    - name: write to file
      local_action: copy content="{{ ansible_facts.droplet_ip }}" dest="/tmp/droplet-ip.txt"

    - name: Add host to inventory
      ansible.builtin.add_host:
        name: "{{ ansible_facts.droplet_ip }}"
        groups: "new_droplet"
        ansible_user: root

- name: setup user
  hosts: new_droplet
  gather_facts: false
  tasks:
    - name: Ensure user "debian" exists
      ansible.builtin.user:
        name: debian
        shell: /bin/bash
        groups: sudo
        create_home: true
        home: /home/debian
        append: yes
        password: "{{ 'foobar123' | password_hash('sha512') }}"

    - name: add ssh key
      ansible.posix.authorized_key:
        user: debian
        state: present
        key: "{{ lookup('file', '~/.ssh/id_rsa.pub') }}"

- name: setup packages
  hosts: new_droplet
  gather_facts: false
  tasks:
    - name: update apt cache
      ansible.builtin.apt:
        update_cache: yes

    - name: Install a list of packages
      ansible.builtin.apt:
        pkg:
          - jq
          - git
          - acl

    - name: safe upgrade
      ansible.builtin.apt:
        upgrade: safe

    - name: dist upgrade
      ansible.builtin.apt:
        upgrade: dist

    - name: Remove dependencies that are no longer required
      ansible.builtin.apt:
        autoremove: yes

    # TODO: poweroff + powercycle here to force new freshest kernel?

- name: install k3s
  hosts: new_droplet
  become: true
  become_user: debian
  environment:
    USER_KUBE_PATH: "{{ ansible_env.HOME }}/.kube"
  tasks:
    - name: Check for kubectl binary
      ansible.builtin.command:
        cmd: "which kubectl"
      register: kubectl_check
      ignore_errors: yes

    - name: Download and install k3s if kubectl not found
      ansible.builtin.shell: "curl -sfL https://get.k3s.io | sh -"
      become: true
      become_user: root
      when: kubectl_check.rc != 0

    - name: get kubeconfig
      ansible.builtin.shell: "k3s kubectl config view --raw"
      become: true
      become_user: root
      register: kubeconfig

    - name: print kubeconfig
      ansible.builtin.debug:
        msg: "kubeconfig: {{ kubeconfig.stdout }}"

    - name: configure kubeconfig for user
      ansible.builtin.shell: |
        mkdir $USER_KUBE_PATH 2> /dev/null
        echo "{{ kubeconfig.stdout }}" > $USER_KUBE_PATH/config
        chmod 600 $USER_KUBE_PATH/config

    - name: write to file
      delegate_to: localhost
      become: true
      become_user: "{{ lookup('env', 'USER') }}"
      ansible.builtin.shell: 'echo "{{ kubeconfig.stdout }}" > /tmp/kubeconfig'

- name: install argocd-cli
  hosts: new_droplet
  gather_facts: false
  become: true
  become_user: debian
  tasks:
    - name: Check for binary
      ansible.builtin.command:
        cmd: "which argocd"
      register: argocd_check
      ignore_errors: yes

    - name: Download and install argocd-cli if not found
      become: true
      become_user: root
      ansible.builtin.shell: "wget https://github.com/argoproj/argo-cd/releases/download/v2.6.7/argocd-linux-amd64 && chmod +x argocd-linux-amd64 && mv argocd-linux-amd64 /usr/local/bin/argocd"
      when: argocd_check.rc != 0

- name: deploy argocd
  hosts: new_droplet
  gather_facts: false
  become: true
  become_user: debian
  environment:
    KUBECONFIG: "{{ ansible_env.HOME }}/.kube/config"
  tasks:
    - name: create namespace
      ansible.builtin.shell: "kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -"

    - name: rollout
      ansible.builtin.shell: |
        kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/v2.6.7/manifests/install.yaml
        kubectl wait deployment -n argocd argocd-server --for condition=Available=True --timeout=90s
      timeout: 300
      retries: 3
      register: result
      until: result.rc == 0

    - name: get IP
      ansible.builtin.shell: "kubectl -n argocd get service/argocd-server -o=jsonpath='{.spec.clusterIP}'"
      register: argocd_server_cluster_ip

    - name: get password
      ansible.builtin.shell: "kubectl -n argocd get secret argocd-initial-admin-secret -o json | jq -r '.data.password' | base64 -d"
      register: argocd_password

    - name: log in to argocd cli
      ansible.builtin.shell: "argocd login {{ argocd_server_cluster_ip.stdout }}:443 --username admin --password {{ argocd_password.stdout }} --insecure"

    - name: print password
      ansible.builtin.debug:
        msg: "argocd admin password: {{ argocd_password.stdout }}"

    - name: write to file
      delegate_to: localhost
      become: true
      become_user: "{{ lookup('env', 'USER') }}"
      ansible.builtin.shell: 'echo "{{ argocd_password.stdout }}" > /tmp/argocd-password.txt'

- name: deploy kubernetes-dashboard
  hosts: new_droplet
  gather_facts: false
  become: true
  become_user: debian
  vars:
    admin_user_yaml: |
      apiVersion: v1
      kind: ServiceAccount
      metadata:
        name: admin-user
        namespace: kubernetes-dashboard
      ---
      apiVersion: rbac.authorization.k8s.io/v1
      kind: ClusterRoleBinding
      metadata:
        name: admin-user
      roleRef:
        apiGroup: rbac.authorization.k8s.io
        kind: ClusterRole
        name: cluster-admin
      subjects:
      - kind: ServiceAccount
        name: admin-user
        namespace: kubernetes-dashboard
  environment:
    KUBECONFIG: "{{ ansible_env.HOME }}/.kube/config"
  tasks:
    - name: create namespace
      ansible.builtin.shell: "kubectl create namespace kubernetes-dashboard --dry-run=client -o yaml | kubectl apply -f -"

    - name: create + roll out argocd app
      ansible.builtin.shell: |
        APP_NAME="kubernetes-dashboard"
        SYNCED_STATUS=$(argocd app get $APP_NAME -o json 2>&1 | jq -r '.status.sync.status')
        HEALTH_STATUS=$(argocd app get $APP_NAME -o json 2>&1 | jq -r '.status.health.status')
        if [ "$SYNCED_STATUS" = "Synced" ] && [ "$HEALTH_STATUS" = "Healthy" ]
        then
          echo "already synced"
        else
          argocd app create $APP_NAME --repo "https://github.com/kubernetes/dashboard.git" --revision "42deb6b32a27296ac47d1f9839a68fab6053e5fc" --path ./aio/deploy/recommended --dest-namespace kubernetes-dashboard --dest-server https://kubernetes.default.svc --upsert
          argocd app sync $APP_NAME
          argocd app wait $APP_NAME
        fi
      timeout: 300
      retries: 3
      register: result
      until: result.rc == 0

    - name: apply admin user
      ansible.builtin.shell: 'echo "{{ admin_user_yaml }}" | kubectl -n kubernetes-dashboard apply -f -'

    - name: get admin user token
      ansible.builtin.shell: "kubectl -n kubernetes-dashboard create token admin-user"
      register: kubernetes_dashboard_token

    - name: print token
      ansible.builtin.debug:
        msg: "kubernetes dashboard admin login token: {{ kubernetes_dashboard_token.stdout }}"

    - name: write to file
      delegate_to: localhost
      become: true
      become_user: "{{ lookup('env', 'USER') }}"
      ansible.builtin.shell: 'echo "{{ kubernetes_dashboard_token.stdout }}" > /tmp/kubernetes-dashboard-token.txt'

- name: deploy docker-registry
  hosts: new_droplet
  gather_facts: false
  become: true
  become_user: debian
  environment:
    KUBECONFIG: "{{ ansible_env.HOME }}/.kube/config"
  tasks:
    - name: create namespace
      ansible.builtin.shell: "kubectl create namespace docker-registry --dry-run=client -o yaml | kubectl apply -f -"

    - name: create + roll out argocd app
      ansible.builtin.shell: |
        APP_NAME="docker-registry"
        SYNCED_STATUS=$(argocd app get $APP_NAME -o json 2>&1 | jq -r '.status.sync.status')
        HEALTH_STATUS=$(argocd app get $APP_NAME -o json 2>&1 | jq -r '.status.health.status')
        if [ "$SYNCED_STATUS" = "Synced" ] && [ "$HEALTH_STATUS" = "Healthy" ]
        then
          echo "already synced"
        else
          argocd app create $APP_NAME --repo "https://github.com/twuni/docker-registry.helm.git" --revision "d74c33abd95567d1641fbfe68f2db85b6135b064" --path . --dest-namespace docker-registry --dest-server https://kubernetes.default.svc --helm-set autoscaling.maxReplicas=1 --upsert
          argocd app sync $APP_NAME
          argocd app wait $APP_NAME
        fi
      timeout: 300
      retries: 3
      register: result
      until: result.rc == 0

    - name: check if registry already configured
      stat:
        path: /etc/rancher/k3s/registries.yaml
      register: registry_configured

    - name: configure registry as insecure (http instead of https)
      become: true
      become_user: root
      ansible.builtin.shell: |
        CLUSTER_IP=$(kubectl -n docker-registry get service/docker-registry -o=jsonpath='{.spec.clusterIP}')
        REGISTRIES_YAML=$(
        cat <<EOF
        mirrors:
          "$CLUSTER_IP:5000":
            endpoint:
              - "http://$CLUSTER_IP:5000"
        EOF
        )
        echo "$REGISTRIES_YAML" | tee /etc/rancher/k3s/registries.yaml
      when: registry_configured.stat.exists == false

    - name: restart k3s to apply registry config change
      become: true
      become_user: root
      ansible.builtin.shell: "systemctl restart k3s"
      when: registry_configured.stat.exists == false

    - name: sleep to allow for k3s cluster to restart
      ansible.builtin.shell: "sleep 30"
      when: registry_configured.stat.exists == false

- name: deploy elasticsearch + kibana
  hosts: new_droplet
  gather_facts: false
  become: true
  become_user: debian
  environment:
    KUBECONFIG: "{{ ansible_env.HOME }}/.kube/config"
  tasks:
    - name: create namespace
      ansible.builtin.shell: "kubectl create namespace elk --dry-run=client -o yaml | kubectl apply -f -"

    - name: create + roll out elasticsearch
      ansible.builtin.shell: |
        APP_NAME="elasticsearch"
        SYNCED_STATUS=$(argocd app get $APP_NAME -o json 2>&1 | jq -r '.status.sync.status')
        HEALTH_STATUS=$(argocd app get $APP_NAME -o json 2>&1 | jq -r '.status.health.status')
        if [ "$SYNCED_STATUS" = "Synced" ] && [ "$HEALTH_STATUS" = "Healthy" ]
        then
          echo "already synced"
        else
          argocd app create $APP_NAME --repo https://github.com/elastic/helm-charts.git --revision "v8.5.1" --path elasticsearch --dest-namespace elk --dest-server https://kubernetes.default.svc --helm-set minimumMasterNodes=1 --helm-set replicas=1 --helm-set minimumMasterNodes=1 --helm-set resources.requests.cpu=0 --helm-set resources.requests.memory=0
          argocd app sync $APP_NAME
          argocd app wait $APP_NAME
        fi
      timeout: 300
      retries: 3
      register: result
      until: result.rc == 0

    - name: create + roll out kibana
      ansible.builtin.shell: |
        APP_NAME="kibana"
        SYNCED_STATUS=$(argocd app get $APP_NAME -o json 2>&1 | jq -r '.status.sync.status')
        HEALTH_STATUS=$(argocd app get $APP_NAME -o json 2>&1 | jq -r '.status.health.status')
        if [ "$SYNCED_STATUS" = "Synced" ] && [ "$HEALTH_STATUS" = "Healthy" ]
        then
          echo "already synced"
        else
          argocd app create $APP_NAME --repo https://github.com/elastic/helm-charts.git --revision "v8.5.1" --path kibana --dest-namespace elk --dest-server https://kubernetes.default.svc --helm-set resources.requests.cpu=0 --helm-set resources.requests.memory=0
          argocd app sync $APP_NAME
          argocd app wait $APP_NAME
        fi
      timeout: 300
      retries: 3
      register: result
      until: result.rc == 0

    - name: get password
      ansible.builtin.shell: "kubectl -n elk get secret elasticsearch-master-credentials -o json | jq -r '.data.password' | base64 -d"
      register: elasticsearch_password

    - name: print password
      ansible.builtin.debug:
        msg: "elasticsearch password: {{ elasticsearch_password.stdout }}"

    - name: write to file
      delegate_to: localhost
      become: true
      become_user: "{{ lookup('env', 'USER') }}"
      ansible.builtin.shell: 'echo "{{ elasticsearch_password.stdout }}" > /tmp/elasticsearch-password.txt'

- name: build app
  hosts: new_droplet
  gather_facts: false
  become: true
  become_user: debian
  environment:
    KUBECONFIG: "{{ ansible_env.HOME }}/.kube/config"
  tasks:
    - name: build app
      ansible.builtin.shell: |
        # exit on errors
        set -e
        # variables
        INTERNAL_REGISTRY_URL="docker-registry.docker-registry.svc.cluster.local:5000"
        REPO_URL="https://github.com/brandonros/argocd-poc.git"
        BRANCH_NAME="master"
        BUILD_CONTEXT_DIRECTORY="./app/"
        APP_NAME="app"
        # clone repo to temp directory
        WORK_DIR=$(mktemp -d -p /tmp)
        git clone --depth=1 --branch "$BRANCH_NAME" "$REPO_URL" "$WORK_DIR"
        # get version from package.json TODO: use git describe --tags --abbrev=0 ?
        VERSION=$(cat "$WORK_DIR/app/package.json" | jq -r '.version')
        # build image tag from APP_NAME + version
        IMAGE_TAG="$APP_NAME:$VERSION"
        # build json overrides for kaniko pod
        OVERRIDES=$(
        cat <<EOF
        {
          "apiVersion": "v1",
          "spec": {
            "containers": [
              {
                "name": "kaniko",
                "image": "gcr.io/kaniko-project/executor:latest",
                "stdin": true,
                "stdinOnce": true,
                "args": [
                  "--dockerfile=Dockerfile",
                  "--context=tar://stdin",
                  "--destination=$INTERNAL_REGISTRY_URL/$IMAGE_TAG"
                ]
              }
            ]
          }
        }
        EOF
        )
        # make sure kaniko namespace exists
        kubectl create namespace kaniko --dry-run=client -o yaml | kubectl apply -f -
        # tar context and send to kubectl run which will pull kaniko executor image
        RANDOM_BYTES=$(echo $RANDOM | md5sum | head -c 10)
        POD_NAME="kaniko-$RANDOM_BYTES"
        DIRECTORY=$(realpath "$WORK_DIR/$BUILD_CONTEXT_DIRECTORY")
        tar --create --file=- --verbose --directory="$DIRECTORY" --gzip --verbose index.mjs package.json package-lock.json Dockerfile .dockerignore | kubectl run -n kaniko \
          "$POD_NAME" \
          --rm \
          --stdin=true \
          --image=gcr.io/kaniko-project/executor:latest \
          --restart=Never \
          --overrides="$OVERRIDES"
        # cleanup
        rm -rf "$WORK_DIR"

- name: deploy app
  hosts: new_droplet
  gather_facts: false
  become: true
  become_user: debian
  environment:
    KUBECONFIG: "{{ ansible_env.HOME }}/.kube/config"
  tasks:
    - name: deploy app
      ansible.builtin.shell: |
        # exit on errors
        set -e
        # get registry IP
        DOCKER_REGISTRY_CLUSTER_IP=$(kubectl -n docker-registry get service/docker-registry -o=jsonpath='{.spec.clusterIP}')
        PORT=5000
        EXTERNAL_REGISTRY_URL="$DOCKER_REGISTRY_CLUSTER_IP:$PORT" # do not use kubernetes internal DNS because kubernetes node does not pull from pod context aka no access to internal DNS
        # variables
        REPO_URL="https://github.com/brandonros/argocd-poc.git"
        BRANCH_NAME="master"
        APP_NAME="app"
        # clone repo to temp directory
        WORK_DIR=$(mktemp -d -p /tmp)
        git clone --depth=1 --branch "$BRANCH_NAME" "$REPO_URL" "$WORK_DIR"
        # get version from package.json TODO: use git describe --tags --abbrev=0 ?
        VERSION=$(cat "$WORK_DIR/app/package.json" | jq -r '.version')
        # build image tag from APP_NAME + version
        IMAGE_TAG="$APP_NAME:$VERSION"
        # create namespace
        kubectl create namespace app --dry-run=client -o yaml | kubectl apply -f -
        # deploy app no matter what to account for possible version changes?
        ELASTICSEARCH_USERNAME=$(kubectl -n elk get secret elasticsearch-master-credentials -o json | jq -r '.data.username' | base64 -d)
        ELASTICSEARCH_PASSWORD=$(kubectl -n elk get secret elasticsearch-master-credentials -o json | jq -r '.data.password' | base64 -d)
        argocd app create $APP_NAME \
          --repo "https://github.com/brandonros/argocd-poc.git" \
          --path ./app/helm/ \
          --dest-namespace app \
          --dest-server https://kubernetes.default.svc \
          --revision-history-limit 1 \
          --helm-set image.repository="$EXTERNAL_REGISTRY_URL" \
          --helm-set image.tag="$IMAGE_TAG" \
          --helm-set env.ELASTICSEARCH_USERNAME="$ELASTICSEARCH_USERNAME" \
          --helm-set env.ELASTICSEARCH_PASSWORD="$ELASTICSEARCH_PASSWORD" \
          --helm-set env.ELASTICSEARCH_URL="https://elasticsearch-master-headless.elk.svc.cluster.local:9200" \
          --upsert
        argocd app sync $APP_NAME --prune
        argocd app wait $APP_NAME
        # cleanup
        rm -rf "$WORK_DIR"
